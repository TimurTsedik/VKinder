# Первые шаги по боту

## Модуль main

В модуле main пока две функции:

1. get_tokens - запись в переменные двух заранее полученных токенов. У меня пока просто из файла, можно откуда угодно брать.
2. start_vk_bot - основная функция, которая отвечает за всю работу бота.
   При поступлении нового сообщения создается экземпляр класса VkBot (вынесен в модуль vk_bot) и текст сообщения передается в метод execute_command.

## Модуль vk_bot

Модуль содержит класс VkBot, в котором все методы для работы с ним:

1. Метод \_\_init\_\_ - на вход принимает два токена и id пользователя, который написал сообщение. В экземпляре сохраняются:
   - Токен сообщества (token_1)
   - Токен пользователя (token_2)
   - Id пользователя (_USER_ID)
   - Данные пользователя, необходимые для поиска (_USER_DATA)
   - Список команд для управления ботом (_COMMANDS)
  
  По поводу токенов: токена два, т. к. отдельные методы VK API не работают с токеном сообщества (например 'users.search').
  Везде, где можно, использую токен группы, где нельзя - перехожу на токен пользователя.
2. Метод _get_user_data_from_vk_id - на вход принимает id пользователя, на выходе словарь с данными пользователя следующего вида:
   {  'age': ,
      'books': '',
      'can_access_closed': True,
      'city': {'id': 49, 'title': 'Екатеринбург'},
      'first_name': 'Александр',
      'id': 44143720,
      'interests': '',
      'is_closed': False,
      'last_name': 'Русских',
      'movies': '',
      'music': '',
      'relation': 4,
      'relation_partner': {'first_name': '',
                      'id': ,
                      'last_name': 'Русских'},
      'sex': 2}
      Данные сохраняются в self._USER_DATA
3. search_boy_girl_friends - метод для поиска пользователей для знакомств. На вход принимате данные пользователя (self._USER_DATA).
   Поиск пока ведется по полям 'city', 'sex', 'age_from', 'age_to'. На выходе - список со словаряvb, в каждом данные по одному пользователю.
   Пока не отработаны случаи, если не указан город, возраст (дата рождения). В итоговый список такие пользователи не попадают.
   Потом надо решить, что с этим делать. Надо ли доп. запрашивать эти данные у пользователя.
4. execute_command - основной метод, который принимает на вход сообщение и вызывает необходимые методы в зависимости от содержания.
5. calculate_age - метод для вычисления возраста пользователя

## Функционал и команды

Пока в черновом варианте реализованы команды "ПРИВЕТ", "ПОКА", "ПОИСК" (без записи в БД, необходимо дополнить код).
Команды "СЛЕДУЮЩИЙ", "ДОБАВИТЬ В ИЗБРАННОЕ", "СПИСОК ИЗБРАННОГО" надо реализовывать после того, как определим конфигурацию БД и способы взаимодействия с ней.

## Логика работы программы

Сейчас логика построена так, что при каждом вводе сообщения пользователем создается объект класса VkBot и выполняются действия в зависимости от сообщения. Это означает что все данные необходимо хранить в БД. Например после выдачи данных по команде "следующий" надо отмечать чьи данные мы выдали, чтобы в следующий раз отправить данные пользователя ниже по списку.
С одной стороны это кажется не совмем оптимально: каждый раз создавать экземпляр класса и хранить лишние данные (правда небольшие).
С другой стороны это обеспечивает работу сразу с несколькими пользователями, когда несколько людей могут писать сообщения в сообществе и программа будет их отрабатывать.

## БД

Тут я бы предложил предусмотреть следующие опции:

1. В сообществе могут писать разные пользователи. У них могут быть разные или одинаковые результаты поиска(частично).
   Может в одной таблице хранить данные по пользователям, которые ищут, в другой - результаты поиска, а связь между ними через промежуточную таблицу мноние ко многим?
2. Допустим для Юзера_1, Юзера_2, Юзера_3 сохранили в базе результаты поиска. В данной реализации для каждого надо хранить текущую позицию в его списке, чтобы при командах "СЛЕДУЮЩИЙ", "ДОБАВИТЬ В ИЗБРАННОЕ" было понятно кого добавлять и кто следующий. Можно это сделать в отдельной таблице, первая колонка - id_пользователя(Юзера_1, Юзера_2, ...) - вторая позиция(id) в его списке интересов, какой пользователь является текущим.

На этом мысли пока заканчиваются.